/*
	leetcode 45: 跳跃游戏II
	给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
	数组中的每个元素代表你在该位置可以跳跃的最大长度。
	你的目标是使用最少的跳跃次数到达数组的最后一个位置。
	假设你总是可以到达数组的最后一个位置。


	输入: nums = [2,3,1,1,4]
	输出: 2
	解释: 跳到最后一个位置的最小跳跃数是 2。
    从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。


	输入: nums = [2,3,0,1,4]
	输出: 2

	思路: 贪心策略
	1. 正向遍历数组，每次找到可以达到的最远位置。
	2. 当前位置上可以达到的目标位置中，选择目标位置可以继续跳跃更远的位置
	3. 可以用一个变量end维护能够到达的最大下标位置，记为边界。从左向右遍历这个数组，到达边界时，更新边界并将跳跃次数增加1
	4. 遍历数组时，不访问最后一个元素，因为访问最后一个元素之前，边界一定 >= 最后一个元素位置，否则无法跳到最后一个位置。如果访问最后一个位置，在边界正好为最后一个元素位置时，会额外增加『不必要的跳跃』，因此不需要遍历至最后一个元素。
*/
package main

func main() {

}

func canJump(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	lenNums := len(nums)
	// 边界
	end := 0
	// 最大位置下标
	maxPos := 0
	// 步数
	steps := 0
	for i := 0; i < lenNums-1; i++ {
		maxPos = max(maxPos, i+nums[i])
		if i == end {
			// 达到边界，更新边界
			end = maxPos
			steps++
		}
	}

	return steps
}

func max(x, y int) int {
	if x > y {
		return x
	}

	return y
}
