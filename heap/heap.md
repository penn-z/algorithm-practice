[TOC]



## 堆

| 堆的用法     | 时间复杂度 | 空间复杂度 |
| ------------ | ---------- | ---------- |
| 创建堆       | O(N)       | O(N)       |
| 插入元素     | O(logN)    | O(1)       |
| 获取堆顶元素 | O(1)       | 0(1)       |
| 删除堆顶元素 | O(logN)    | O(1)       |
| 获取堆长度   | O(1)       | O(1)       |



## TopK问题

eg: 求最大的K个元素;

### 解法一

1. 创建一个==最大堆==
2. 将所有元素都加到==最大堆==中;
3. 通过『边删除边遍历』方法，讲堆顶元素删除，并将它保存到结果集T中;
4. 重复3步骤==K==次，直到取出前K个最大元素;



### 解法二

1. 创建一个大小为==K==的==最小堆==;

2. 依次将元素添加到==最小堆==中;

3. 当最小堆的元素个数达到==K==时，将当前元素与堆顶元素进行对比:

   >1. 如果当前元素小于堆顶元素，则放弃当前元素，继续进行下一个元素;
   >2. 如果当前元素大于堆顶元素，则删除堆顶元素，将当前元素加入到最小堆中

4. 重复步骤2和步骤3，知道所有元素遍历完毕;

5. 此时最小堆中的k个元素就是前==K==个最大元素。





## The Kth问题

eg: 求第K大元素



### 解法一

1. 创建一个==最大堆==;
2. 将所有元素加入到==最大堆==中;
3. 通过『边删除边遍历』方法，将堆顶元素删除;
4. 重复3步骤==K==次，直到获取到第==K==个最大的元素;





### 解法二

1. 创建一个大小为==K==的==最小堆==;

2. 依次将元素添加到==最小堆==中：

3. 当==最小堆==的元素达到==K==个时，将当前元素与堆顶元素进行对比:

   >1. 如果当前元素小于堆顶元素，则放弃当前元素，继续进行一个元素;
   >
   >2. 如果当前元素大于堆顶元素，则删除堆顶元素，将当前元素加入到==最小堆==中

4. 重复步骤2和步骤3，直到所有元素遍历完毕

5. 此时==最小堆==中的堆顶元素就是第==K==个最大的元素。



